p_setosa <- predict(classifier_RF, newdata = test, type = "prob")[,1]
calibration(test$Species == "setosa", p_setosa)
length(p_setosa)
nrow(test)
p_setosa
calibration(test$Species == "setosa", p_setosa)
calibration <- function(y, p, n = 10000, ...){
d <- data.frame(y = y, p = p) %>% arrange(p) %>% mutate(e = y - p, V = p*(1-p)/nrow(d)^2, W = cumsum(e) / nrow(d))
supW <- with(d, max(abs(W)))
n_timepoints <- length(p)
A <- matrix(rnorm(n*n_timepoints), nrow = n, ncol = n_timepoints)
for(i in 1:n_timepoints){
A[,i] <- A[,i] * sqrt(d$V[i])
}
for(i in 1:n){
A[i,] <- cumsum(A[i,])
}
pvalue <- mean(apply(A, 1, function(i) max(abs(i)) > supW))
options(scipen=999)
with(d, plot(p, W * 100, type = "l",
ylim = c(-max(max(abs(A[1:50,])), max(abs(d$W))) * 100, max(max(abs(A[1:50,])), max(abs(d$W))) * 100),
las = 1, xlab = "Estimated probability", ylab = "Cumulative residual", lwd = 2, axes=F,#bty = "n",
main = "Calibration test", xlim = c(0,1), ...))
axis(1,lwd=2)
axis(2,lwd=2, las = 1)
legend("bottomleft", legend = paste0("pvalue = ", round(pvalue, 3)), bty = "n", cex = 1.5)
legend("topleft", legend = c("Realized", "Simulated"), col = c("black", "gray"), bty = "n", pch = "-", cex = 1.5, lwd = 5)
for(i in 1:50){
lines(d$p, A[i,] * 100, type = "l", col = "gray")
}
with(d, lines(p, W * 100, lwd = 2))
}
calibration(test$Species == "setosa", p_setosa)
str(test)
p_versicolor <- predict(classifier_RF, newdata = test, type = "prob")[,2]
calibration(test$Species == "versicolor", p_setosa)
p_versicolor
library(stringr)
# English
d <- words::words
words <- tolower(d[,1])
install.packages("words")
# English
d <- words::words
words <- tolower(d[,1])
mysubset <- function(d, size = 5, notin = NULL, contains = NULL, known = NULL, pos = NULL, bestWord = FALSE){
words <- d[nchar(d) == size]
words <- d <- words[!unlist(if(length(words) != 0) lapply(strsplit(words, ""), function(i) any(i %in% c("-", " ", "/", ".") )) else character(0))]
if(!is.null(notin) & !is.null(contains)) notin <- paste(setdiff(strsplit(notin, "")[[1]], strsplit(contains, "")[[1]]), collapse = "")
if(!is.null(notin)){
notin <- strsplit(notin, "")[[1]]
for(i in 1:length(notin)){
words <- words[!str_detect(words, notin[i])]
}
}
if(!is.null(contains) && !identical(contains, "")){
contains <- strsplit(contains, "")[[1]]
known <- as.numeric(strsplit(known, "")[[1]])
pos <- as.numeric(strsplit(pos, "")[[1]])
if(length(contains) != length(known) | length(known) != length(pos)){
warning("contains, known, and pos must have equal length")
}
for(i in 1:length(contains)){
if(known[i]){
words <- words[substr(words, pos[i], pos[i]) == contains[i]]
}
else{
words <- words[substr(words, pos[i], pos[i]) != contains[i]]
words <- words[str_detect(words, contains[i])]
}
}
}
cat("Number of words:", length(words), "\n")
# test <- if(length(words) != 0) lapply(strsplit(words, ""), function(i) length(unique(i))) == length else F
if(bestWord){
howmany <- rep(NA, length(words))
for(i in 1:length(words)){
howmany[i] <- checkword(words[i], words)
}
most <- which(howmany == max(howmany))
test <- if(length(most) != 0) lapply(strsplit(words[most], ""), function(i) length(unique(i))) == size else F
# cat("Word:", ifelse(any(test == 1), words[match(1, test)], words[1]), "\n")
if(any(test == 1)){
cat("Words:", sample(words[most[which(test == 1)]], 1), "\n")
}
else{
cat("Words:", sample(words[most], 1), "\n")
}
# cat("Word:", ifelse(any(test == 1), words[most[which(test == 1)]], words[most]), "\n")
}
if(!is.null(known) && !identical(known, "")){
if(length(unique(pos[known == 1])) == (size - 1) & length(words) >= 3){
subwords <- strsplit(words, "")
tmp <- rep(NA, length(words))
for(i in 1:length(words)) tmp[i] <- subwords[[i]][!((1:size) %in% pos[known == 1])]
dsub <- d[!(d %in% words)]
for(i in 1:(size-1)){
position <- unique(pos[known == 1])[i]
dsub <- dsub[substr(dsub, position, position) != unique(substr(words, position, position))]
}
howmany <- rep(NA, length(dsub))
for(i in 1:length(dsub)){
howmany[i] <- checkword(dsub[i], tmp)
}
most <- which(howmany == max(howmany))
test <- if(length(most) != 0) lapply(strsplit(dsub[most], ""), function(i) length(unique(i))) == size else F
# cat("Word:", ifelse(any(test == 1), words[match(1, test)], words[1]), "\n")
if(any(test == 1)){
cat("Words:", sample(dsub[most[which(test == 1)]], 1), "\n")
}
else{
cat("Words:", sample(dsub[most],1), "\n")
}
}
}
correct <- readline(prompt = "Correct? ")
if(!as.logical(correct)){
notinAdd <- readline(prompt = "notin? ")
containsAdd <- readline(prompt = "contains? ")
knownAdd <- readline(prompt = "known? ")
posAdd <- readline(prompt = "pos? ")
notin <- paste(c(notin, notinAdd), collapse = "")
contains <- paste(c(contains, containsAdd), collapse = "")
known <- paste(c(known, knownAdd), collapse = "")
pos <- paste(c(pos, posAdd), collapse = "")
mysubset(words, size = size, notin = notin, contains = contains, known = known, pos = pos, bestWord = TRUE)
}
else{
cat("You're welcome!")
}
# cat("Words: ", words[1:5], "\n")
}
checkword <- function(word, dictionary){
word <- paste0("(", paste0(strsplit(word, "")[[1]], collapse = ")|("), ")")
sum(grepl(word, dictionary))
}
mysubset(words, size = 5, bestWord = FALSE)
?ks.test
ks.test
getAnywhere(ks.tst)
getAnywhere(ks.test)
stats::ks.test
getAnywhere(stats::ks.test)
library(Publish)
install.packages("Publish")
library(Publish)
publish?
)
?publish
browseVignettes(Publish)
browseVignettes("Publish")
?uTable
?utable()
library(survival)
survfit.coxph
getAnywhere(survfit.coxph)
rm(list=ls())
set.seed(13072020)
library(rstudioapi)
library(data.table)
library(haven)
library(tidyverse)
library(survival)
library(doRNG)
library(doParallel)
cl <- parallel::makeCluster(7)
doParallel::registerDoParallel(cl)
setwd(dirname(getSourceEditorContext()$path))
source("functions.R")
n <- 1e4                                                  # Antal obs
lambda <- 1e-4                                            # Konstant baseline hazard
HR <- 1                                                   # HR af behandling
HRsex <- 2
# tau <- rexp(n, rate=1/1000)                               # Censorering
## tau <- 1000
lambdaPois <- 3                                           # Parameter til poissonfordeling
D <- 100                                                  # Behandlingslængde
M <- 4
starttime <- Sys.time()
ests <- foreach(i = 1:10, .combine = "rbind", .options.RNG = 05102022,
.packages = c("data.table", "survival")) %dorng% {
cat("outer iteration: ", i, "\n")
# W <- rpois(n, lambda = lambdaPois) + 1                         # Antal behandlinger
sex <- rbinom(n, 1, .5)
W <- rpois(n, lambda = lambdaPois) + 1
W[sex == 1] <- rpois(sum(sex == 1), lambda = 2) + 1
# W <- sample(1:4, n, replace = TRUE, prob = c(.1,.2,.2,.5))
# W[sex == 1] <- rpois(sum(sex == 1), lambda = 2) + 1
UW <- (W == 1) + 2 * (W == 2) + 3 * (W == 3) + 4 * (W >= 4)    # HR for forskellige antal behandlinger
# UW <- pmin(exp(W - 4), 1)
u <- runif(n)
br <- 1 - exp(-lambda * W * D * UW * HR * HRsex^sex)
X <- numeric(n)
X[u < br] <- -log(1 - u[u < br]) / (lambda * HR * UW[u < br] * HRsex^sex[u < br])
X[u >= br] <- (-log(1 - u[u >= br]) + lambda * UW[u >= br] * HRsex^sex[u >= br] * W[u >= br] * D * (1 - HR)) /
(lambda * UW[u >= br] * HRsex^sex[u >= br])
tau <- runif(n, 0, 1000)                                       # Censorering
T <- pmin(X, tau)
status <- as.numeric(X <= tau)
obsW <- pmin(W, ceiling(T / D))                                # Vi observerer ikke W for alle
treat <- as.numeric(T <= (D * W))                              # Behandling eller ej ved event tidspunkt
statusW <- 1-treat                                             # Fortæller os om vi observerer W
statusW[obsW >= M] <- 1                                        # Vi kender niveau hvis de behandles 4 eller flere gange
tmp <- do.call("rbind", lapply(1:n, function(i){
if(treat[i] == 1) data.table(id = i, time1 = 0, time2 = T[i], status = status[i], treat = 0, W = min(obsW[i],M),
statusW = statusW[i], sex = sex[i])
else data.table(id = i, time1 = c(0, D*W[i]), time2 = c(D*W[i], T[i]), status = c(0, status[i]),
treat = c(0,1), W = min(obsW[i],M), statusW = statusW[i], sex = sex[i])
}))
cox1 <- coxph(Surv(time1,time2,status) ~ treat + sex, data = tmp)
cc <- confint(cox1)
cox1_cov <- cc[1,1] < 0 & cc[1,2] > 0
cox2 <- coxph(Surv(time1,time2,status) ~ treat + strata(factor(W)) + sex, data = tmp)
cc <- confint(cox2)
cox2_cov <- cc[1,1] < 0 & cc[1,2] > 0
model <- em(Surv(time1,time2,status) ~ treat + strata(factor(W)) + sex, data = tmp, M = M)
ests <- coef(model$model)[1]
SE <- emSE(model)[1]
cat("estimate", i, ": ", ests, "\n")
cat("standard error", i, ": ", SE, "\n")
nn <- floor((T-1e-10) / D)
tmp2 <- do.call("rbind", lapply(1:n, function(i){
sek <- seq(0, D * nn[i], D)
data.table(id = i, time1 = sek, time2 = c(sek[-1], T[i]), status = c(rep(0, length(sek)-1), status[i]),
sex = sex[i], treat = c(rep(0, obsW[i]), rep(1, length(sek) - obsW[i])),
W = c(1:obsW[i], rep(obsW[i], length(sek) - obsW[i])))
}))
tmp2$W[tmp2$W >= M] <- M
cox3 <- coxph(Surv(time1,time2,status) ~ treat + sex + strata(factor(W)), data = tmp2)
cc <- confint(cox3)
cox3_cov <- cc[1,1] < 0 & cc[1,2] > 0
cat("newCox", i, ": ", coef(cox3)[1], "\n")
c(ests, SE, coef(cox1)[1], coef(cox2)[1], coef(cox3)[1], cox1_cov, cox2_cov, cox3_cov)
# c(ests, SE, coef(cox1)[1], coef(cox2)[1])
## c(i, ests)
}
endtime <- Sys.time()
difftime(endtime,starttime)
basehaz
?basehaz
difftime(endtime,starttime)
apply(ests,2,mean)
# W <- rpois(n, lambda = lambdaPois) + 1                         # Antal behandlinger
sex <- rbinom(n, 1, .5)
W <- rpois(n, lambda = lambdaPois) + 1
W[sex == 1] <- rpois(sum(sex == 1), lambda = 2) + 1
# W <- sample(1:4, n, replace = TRUE, prob = c(.1,.2,.2,.5))
# W[sex == 1] <- rpois(sum(sex == 1), lambda = 2) + 1
UW <- (W == 1) + 2 * (W == 2) + 3 * (W == 3) + 4 * (W >= 4)    # HR for forskellige antal behandlinger
# UW <- pmin(exp(W - 4), 1)
u <- runif(n)
br <- 1 - exp(-lambda * W * D * UW * HR * HRsex^sex)
X <- numeric(n)
X[u < br] <- -log(1 - u[u < br]) / (lambda * HR * UW[u < br] * HRsex^sex[u < br])
X[u >= br] <- (-log(1 - u[u >= br]) + lambda * UW[u >= br] * HRsex^sex[u >= br] * W[u >= br] * D * (1 - HR)) /
(lambda * UW[u >= br] * HRsex^sex[u >= br])
tau <- runif(n, 0, 1000)                                       # Censorering
T <- pmin(X, tau)
status <- as.numeric(X <= tau)
obsW <- pmin(W, ceiling(T / D))                                # Vi observerer ikke W for alle
treat <- as.numeric(T <= (D * W))                              # Behandling eller ej ved event tidspunkt
statusW <- 1-treat                                             # Fortæller os om vi observerer W
statusW[obsW >= M] <- 1                                        # Vi kender niveau hvis de behandles 4 eller flere gange
nn <- floor((T-1e-10) / D)
tmp2 <- do.call("rbind", lapply(1:n, function(i){
sek <- seq(0, D * nn[i], D)
data.table(id = i, time1 = sek, time2 = c(sek[-1], T[i]), status = c(rep(0, length(sek)-1), status[i]),
sex = sex[i], treat = c(rep(0, obsW[i]), rep(1, length(sek) - obsW[i])),
W = c(1:obsW[i], rep(obsW[i], length(sek) - obsW[i])))
}))
tmp2$W[tmp2$W >= M] <- M
cox3 <- coxph(Surv(time1,time2,status) ~ treat + sex + strata(factor(W)), data = tmp2)
cc <- confint(cox3)
cox3_cov <- cc[1,1] < 0 & cc[1,2] > 0
cox3
basehaz(cox3)
subset(basehaz, strata == 2)
subset(basehaz, strata == "2")
subset(basehaz(cox3), strata == 2)
cl <- parallel::makeCluster(6)
doParallel::registerDoParallel(cl)
library(devtools)
install_github("Jeepen/biSurv")
setwd("C:/Users/vcl891/Documents/biSurv")
library(devtools)
document()
update.packages(checkBuilt=TRUE)
install.packages("curl")
install.packages("curl")
document()
update.packages(checkBuilt=TRUE, ask = FALSE)
check()
sessionInfo()
update.packages(checkBuilt=TRUE, ask = FALSE, INSTALL_opts="--no-multiarch")
library(stringr)
# English
d <- words::words
words <- tolower(d[,1])
mysubset <- function(d, size = 5, notin = NULL, contains = NULL, known = NULL, pos = NULL, bestWord = FALSE){
words <- d[nchar(d) == size]
words <- d <- words[!unlist(if(length(words) != 0) lapply(strsplit(words, ""), function(i) any(i %in% c("-", " ", "/", ".") )) else character(0))]
if(!is.null(notin) & !is.null(contains)) notin <- paste(setdiff(strsplit(notin, "")[[1]], strsplit(contains, "")[[1]]), collapse = "")
if(!is.null(notin)){
notin <- strsplit(notin, "")[[1]]
for(i in 1:length(notin)){
words <- words[!str_detect(words, notin[i])]
}
}
if(!is.null(contains) && !identical(contains, "")){
contains <- strsplit(contains, "")[[1]]
known <- as.numeric(strsplit(known, "")[[1]])
pos <- as.numeric(strsplit(pos, "")[[1]])
if(length(contains) != length(known) | length(known) != length(pos)){
warning("contains, known, and pos must have equal length")
}
for(i in 1:length(contains)){
if(known[i]){
words <- words[substr(words, pos[i], pos[i]) == contains[i]]
}
else{
words <- words[substr(words, pos[i], pos[i]) != contains[i]]
words <- words[str_detect(words, contains[i])]
}
}
}
cat("Number of words:", length(words), "\n")
# test <- if(length(words) != 0) lapply(strsplit(words, ""), function(i) length(unique(i))) == length else F
if(bestWord){
howmany <- rep(NA, length(words))
for(i in 1:length(words)){
howmany[i] <- checkword(words[i], words)
}
most <- which(howmany == max(howmany))
test <- if(length(most) != 0) lapply(strsplit(words[most], ""), function(i) length(unique(i))) == size else F
# cat("Word:", ifelse(any(test == 1), words[match(1, test)], words[1]), "\n")
if(any(test == 1)){
cat("Words:", sample(words[most[which(test == 1)]], 1), "\n")
}
else{
cat("Words:", sample(words[most], 1), "\n")
}
# cat("Word:", ifelse(any(test == 1), words[most[which(test == 1)]], words[most]), "\n")
}
if(!is.null(known) && !identical(known, "")){
if(length(unique(pos[known == 1])) == (size - 1) & length(words) >= 3){
subwords <- strsplit(words, "")
tmp <- rep(NA, length(words))
for(i in 1:length(words)) tmp[i] <- subwords[[i]][!((1:size) %in% pos[known == 1])]
dsub <- d[!(d %in% words)]
for(i in 1:(size-1)){
position <- unique(pos[known == 1])[i]
dsub <- dsub[substr(dsub, position, position) != unique(substr(words, position, position))]
}
howmany <- rep(NA, length(dsub))
for(i in 1:length(dsub)){
howmany[i] <- checkword(dsub[i], tmp)
}
most <- which(howmany == max(howmany))
test <- if(length(most) != 0) lapply(strsplit(dsub[most], ""), function(i) length(unique(i))) == size else F
# cat("Word:", ifelse(any(test == 1), words[match(1, test)], words[1]), "\n")
if(any(test == 1)){
cat("Words:", sample(dsub[most[which(test == 1)]], 1), "\n")
}
else{
cat("Words:", sample(dsub[most],1), "\n")
}
}
}
correct <- readline(prompt = "Correct? ")
if(!as.logical(correct)){
notinAdd <- readline(prompt = "notin? ")
containsAdd <- readline(prompt = "contains? ")
knownAdd <- readline(prompt = "known? ")
posAdd <- readline(prompt = "pos? ")
notin <- paste(c(notin, notinAdd), collapse = "")
contains <- paste(c(contains, containsAdd), collapse = "")
known <- paste(c(known, knownAdd), collapse = "")
pos <- paste(c(pos, posAdd), collapse = "")
mysubset(words, size = size, notin = notin, contains = contains, known = known, pos = pos, bestWord = TRUE)
}
else{
cat("You're welcome!")
}
# cat("Words: ", words[1:5], "\n")
}
checkword <- function(word, dictionary){
word <- paste0("(", paste0(strsplit(word, "")[[1]], collapse = ")|("), ")")
sum(grepl(word, dictionary))
}
mysubset(words, size = 5, bestWord = FALSE)
mysubset(words, size = 5, bestWord = FALSE)
bass <- basehaz(cox3)
subset(bass, strata == 2)
subset(bass, strata == 1)
cox1
cox1 <- coxph(Surv(time1,time2,status) ~ treat + sex, data = tmp)
tmp <- do.call("rbind", lapply(1:n, function(i){
if(treat[i] == 1) data.table(id = i, time1 = 0, time2 = T[i], status = status[i], treat = 0, W = min(obsW[i],M),
statusW = statusW[i], sex = sex[i])
else data.table(id = i, time1 = c(0, D*W[i]), time2 = c(D*W[i], T[i]), status = c(0, status[i]),
treat = c(0,1), W = min(obsW[i],M), statusW = statusW[i], sex = sex[i])
}))
cox1 <- coxph(Surv(time1,time2,status) ~ treat + sex, data = tmp)
head(tmp)
mean(statusW)
bass1 <- basehaz(cox1)
subset(bass1, strata == 1)[1:5]
subset(bass1)[1:5]
bass1
bass1[1:5,]
bass[1:5,]
coef(cox1)
coef(cox3)
bass3 <- bass
bass1 <- basehaz(cox1, centered = FALSE)
bass3 <- basehaz(cox3, centered = FALSE)
bass1[1:5,]
bass3[1:5,]
cox11 <- cox1
coef(cox11) <- c(0,0)
cox11$coefficients <- c(0,0)
cox33 <- cox3
cox33$coefficients <- c(0,0)
bass1 <- basehaz(cox11, centered = FALSE)
bass3 <- basehaz(cox33, centered = FALSE)
bass1[1:5,]
bass3[1:5,]
subset(bass3, strata == 2)[1:5,]
subset(bass3, time > 100)[1:5,]
subset(bass1, time > 100)[1:5,]
subset(bass3, strata == 2)[1:5,]
diff(subset(bass1, time > 100)[1:5,]$hazard)
diff(subset(bass3, strata == 2)[1:5,]$hazard)
tmp2
head(tmp2,20)
head(tmp2,30)
diff(subset(bass1, time > 100)[1:5,]$hazard)
diff(subset(bass3, strata == 2)[1:5,]$hazard)
setwd("C:/Users/vcl891/Documents/biSurv")
library(devtools)
document()
document()
build()
install(build_vignettes = TRUE)
document()
install_github("kkholst/gof")
install_github("kkholst/targeted")
starttime <- Sys.time()
ests <- foreach(i = 1:10, .combine = "rbind", .options.RNG = 05102022,
.packages = c("data.table", "survival")) %dorng% {
cat("outer iteration: ", i, "\n")
# W <- rpois(n, lambda = lambdaPois) + 1                         # Antal behandlinger
sex <- rbinom(n, 1, .5)
W <- rpois(n, lambda = lambdaPois) + 1
W[sex == 1] <- rpois(sum(sex == 1), lambda = 2) + 1
# W <- sample(1:4, n, replace = TRUE, prob = c(.1,.2,.2,.5))
# W[sex == 1] <- rpois(sum(sex == 1), lambda = 2) + 1
UW <- (W == 1) + 2 * (W == 2) + 3 * (W == 3) + 4 * (W >= 4)    # HR for forskellige antal behandlinger
# UW <- pmin(exp(W - 4), 1)
u <- runif(n)
br <- 1 - exp(-lambda * W * D * UW * HR * HRsex^sex)
X <- numeric(n)
X[u < br] <- -log(1 - u[u < br]) / (lambda * HR * UW[u < br] * HRsex^sex[u < br])
X[u >= br] <- (-log(1 - u[u >= br]) + lambda * UW[u >= br] * HRsex^sex[u >= br] * W[u >= br] * D * (1 - HR)) /
(lambda * UW[u >= br] * HRsex^sex[u >= br])
tau <- runif(n, 0, 1000)                                       # Censorering
T <- pmin(X, tau)
status <- as.numeric(X <= tau)
obsW <- pmin(W, ceiling(T / D))                                # Vi observerer ikke W for alle
treat <- as.numeric(T <= (D * W))                              # Behandling eller ej ved event tidspunkt
statusW <- 1-treat                                             # Fortæller os om vi observerer W
statusW[obsW >= M] <- 1                                        # Vi kender niveau hvis de behandles 4 eller flere gange
tmp <- do.call("rbind", lapply(1:n, function(i){
if(treat[i] == 1) data.table(id = i, time1 = 0, time2 = T[i], status = status[i], treat = 0, W = min(obsW[i],M),
statusW = statusW[i], sex = sex[i])
else data.table(id = i, time1 = c(0, D*W[i]), time2 = c(D*W[i], T[i]), status = c(0, status[i]),
treat = c(0,1), W = min(obsW[i],M), statusW = statusW[i], sex = sex[i])
}))
cox1 <- coxph(Surv(time1,time2,status) ~ treat + sex, data = tmp)
cc <- confint(cox1)
cox1_cov <- cc[1,1] < 0 & cc[1,2] > 0
cox2 <- coxph(Surv(time1,time2,status) ~ treat + strata(factor(W)) + sex, data = tmp)
cc <- confint(cox2)
cox2_cov <- cc[1,1] < 0 & cc[1,2] > 0
model <- em(Surv(time1,time2,status) ~ treat + strata(factor(W)) + sex, data = tmp, M = M)
ests <- coef(model$model)[1]
SE <- emSE(model)[1]
cat("estimate", i, ": ", ests, "\n")
cat("standard error", i, ": ", SE, "\n")
nn <- floor((T-1e-10) / D)
tmp2 <- do.call("rbind", lapply(1:n, function(i){
sek <- seq(0, D * nn[i], D)
data.table(id = i, time1 = sek, time2 = c(sek[-1], T[i]), status = c(rep(0, length(sek)-1), status[i]),
sex = sex[i], treat = c(rep(0, obsW[i]), rep(1, length(sek) - obsW[i])),
W = c(1:obsW[i], rep(obsW[i], length(sek) - obsW[i])))
}))
tmp2$W[tmp2$W >= M] <- M
cox3 <- coxph(Surv(time1,time2,status) ~ treat + sex + strata(factor(W)), data = tmp2)
cc <- confint(cox3)
cox3_cov <- cc[1,1] < 0 & cc[1,2] > 0
cat("newCox", i, ": ", coef(cox3)[1], "\n")
c(ests, SE, coef(cox1)[1], coef(cox2)[1], coef(cox3)[1], cox1_cov, cox2_cov, cox3_cov)
# c(ests, SE, coef(cox1)[1], coef(cox2)[1])
## c(i, ests)
}
endtime <- Sys.time()
difftime(endtime,starttime)
setwd("C:/Users/vcl891/Documents/EM_algoritme/Code")
dd <- readRDS("simresults07102022.rds")
dd
head(dd)
nrow(dd)
